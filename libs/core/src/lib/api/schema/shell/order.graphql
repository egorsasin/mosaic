type Query {
  "The active Order."
  activeOrder: Order
  """
  Returns an Order based on the order `code`. For guest Orders (i.e. Orders placed by non-authenticated Customers)
  this query will only return the Order within 2 hours of the Order being placed. This allows an Order confirmation
  screen to be shown immediately after completion of a guest checkout, yet prevents security risks of allowing
  general anonymous access to Order data.
  """
  orderByCode(code: String!): Order
}

type Mutation {
  "Adds an item to the order."
  addItemToOrder(productId: Int!, quantity: Int!): UpdateOrderItemsResult!
  "Add a Payment to the Order"
  addPaymentToOrder(input: PaymentInput!): AddPaymentToOrderResult!
  """
  Adjusts an OrderLine. If custom fields are defined on the OrderLine entity,
  a third argument 'customFields' of type `OrderLineCustomFieldsInput` will be available.
  """
  adjustOrderLine(orderLineId: Int!, quantity: Int!): UpdateOrderItemsResult!
  "Remove an OrderLine from the Order"
  removeOrderLine(orderLineId: Int!): RemoveOrderItemResult!
  "Sets the shipping method to the Order"
  setOrderShippingMethod(input: ShippingInput!): SetOrderShippingMethodResult!
  "Set the Customer for the Order. Required only if the Customer is not currently logged in"
  setCustomerForOrder(input: CreateCustomerInput!): SetCustomerForOrderResult!
}

"Returned when attempting to set a negative OrderLine quantity."
type NegativeQuantityError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"Returned when attempting to set a negative OrderLine quantity."
type NegativeQuantityError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"Returned when attempting to set the Customer for an Order when already logged in."
type AlreadyLoggedInError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when invoking a mutation which depends on there being an active Order on the
current session.
"""
type NoActiveOrderError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

input ShippingInput {
  shippingMethodId: Int!
  metadata: JSON
}

"Passed as input to the `addPaymentToOrder` mutation."
input PaymentInput {
  "This field should correspond to the `code` property of a PaymentMethod."
  method: String!
  """
  This field should contain arbitrary data passed to the specified PaymentMethodHandler's `createPayment()` method
  as the "metadata" argument. For example, it could contain an ID for the payment and other
  data generated by the payment provider.
  """
  metadata: JSON!
}

union UpdateOrderItemsResult = Order | NegativeQuantityError

union AddPaymentToOrderResult = Order | NoActiveOrderError

union RemoveOrderItemResult = Order | OrderModificationError

union SetOrderShippingMethodResult =
    Order
  | OrderModificationError
  | NoActiveOrderError

union SetCustomerForOrderResult =
    Order
  | AlreadyLoggedInError
  | EmailAddressConflictError
  | NoActiveOrderError
  | GuestCheckoutError

"Returned when attempting to create a Customer with an email address already registered to an existing User."
type EmailAddressConflictError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"Returned when attempting to set the Customer on a guest checkout when the configured GuestCheckoutStrategy does not allow it."
type GuestCheckoutError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  errorDetail: String!
}
